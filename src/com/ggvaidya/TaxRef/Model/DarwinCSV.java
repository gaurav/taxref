
/*
 *
 *  DarwinCSV
 *  Copyright (C) 2012 Gaurav Vaidya
 *
 *  This file is part of TaxonValid.
 *
 *  TaxonValid is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  TaxonValid is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with TaxonValid.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

package com.ggvaidya.TaxRef.Model;

import au.com.bytecode.opencsv.*;
import java.awt.Component;
import java.awt.Color;
import java.io.*;
import java.util.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.table.*;
import org.apache.commons.lang3.*;
import java.util.regex.*;
import java.text.*;
import com.ggvaidya.TaxRef.Common.*;

/**
 * A DarwinCSV is a CSV file with unique, non-repeating column names.
 * This code can also parse tab-delimited and semicolon delimited files,
 * so it should be able to handle any file that comes out of a Darwin Core
 * Archive. Eventually, I'll write a wrapper that can process DwC-A files
 * directly.
 * 
 * @author Gaurav Vaidya <gaurav@ggvaidya.com>
 */
public class DarwinCSV implements TableModel, TableCellRenderer {
	private char separator = ',';
	private char quotechar = '"';
	
	private File myFile;
	private int myType;
	private HashMap<String, Integer> columnNames;
	private HashMap<String, Integer> columnNames_caseInsensitive;
	private List<String> columns;
	private List<String[]> data;
	private HashSet<String> names = new HashSet<String>();
	private HashSet<Integer> nameColumns = new HashSet<Integer>();
	
	public String toString() {
		String type = "CSV";
		if(myType == FILE_TAB_DELIMITED) {
			type = "tab-delimited";
		} else if(myType == FILE_SEMI_DELIMITED) {
			type = "semicolon-delimited";
		}
		
		return "DarwinCSV from " + type + " file '" + myFile.getAbsolutePath() + "' containing " + data.size() + " rows";
	}
	
	private String colsUsedToGenerateCanonicalName = null;
		// null = canonical name provided in file
		// other = we generated them; a list of fields in a format that
		//		fits in the message "autogenerated from XXX"
	
	private int col_scientificname = -1;
	private int col_canonicalname = -1;
	private int col_family = -1;
	private int col_acceptedname = -1;
	private int col_genus = -1;
	private int col_species = -1;
	private int col_subspecies = -1;
	
	public static final int FILE_CSV_DELIMITED = 0;
	public static final int FILE_TAB_DELIMITED = 1;
	public static final int FILE_SEMI_DELIMITED = 2;

	public DarwinCSV(File file) throws IOException {
		// Guess the file type from the first line.
		BufferedReader r = new BufferedReader(new FileReader(file));
		String firstLine = r.readLine();
		
		/* TODO: Eventually, like this will figure out what kind
		 of file we have. But right now, we do not care. */
		
		int parts_csv = firstLine.split(",").length;
		int parts_tabs = firstLine.split("\t").length;
		int parts_semi = firstLine.split(";").length;
		
		if((parts_semi > parts_tabs) && (parts_semi > parts_csv)) {
			setup(file, FILE_SEMI_DELIMITED);
		} else if((parts_tabs > parts_semi) && (parts_tabs > parts_csv)) {
			setup(file, FILE_TAB_DELIMITED);
		} else {
			setup(file, FILE_CSV_DELIMITED);
		}
	}
	
	public DarwinCSV(File file, int file_type) throws IOException {
		setup(file, file_type);
	}
	
	/**
	 * Set up this Darwin CSV. In particular, it'll read
	 * the file header and double-check if:
	 * 
	 *	(1) every column name is unique, and
	 *  (2) see if we can identify any columns that are
	 *		useful for us.
	 * 
	 * @param file The file to process.
	 * @param file_type The file type - CSV, tab-delimited, semi-delimited.
	 */
	public final void setup(File file, int file_type) throws IOException {
		if(file_type == FILE_CSV_DELIMITED) {
			// Default.
		} else if(file_type == FILE_TAB_DELIMITED) {
			separator = '\t';
		} else if(file_type == FILE_SEMI_DELIMITED) {
			separator = ';';
		}
		
		CSVReader csvr = new CSVReader(new BufferedReader(new FileReader(file)), separator);
		columns = new ArrayList<String>();
		columns.addAll(Arrays.asList(csvr.readNext()));
		checkColumns();	// To check for duplicates.
		
		data = csvr.readAll();
		indexNames();
		checkColumns(); // To check for duplicates, and to index column names.
		
		myFile = file;
		myType = file_type;
	}
	
	private void checkColumns() throws IOException {
		// 1. All columns must be unique.
		columnNames = new HashMap<String, Integer>(columns.size());
		columnNames_caseInsensitive = new HashMap<String, Integer>(columns.size());
		
		int x = 0;
		for(String colName: columns) {
			columnNames.put(colName, x);
			columnNames_caseInsensitive.put(colName.toLowerCase(), x);
			x++;
		}
		
		if(columnNames.size() < columns.size()) {
			throw new IOException("Duplicate column names: " + StringUtils.join(columnNames, ", "));
		}
		
		// 2. See if we can identify any scientific names.
		col_canonicalname = column("canonicalname", "canonical_name");
		col_scientificname = column("scientificname", "scientific_name", "scientific name", "name");
		col_acceptedname = column("acceptedNameUsage",  "acceptedName", "acceptedname", "accepted_name");
		col_family = column("family");
		col_genus = column("genus");
		col_species = column("specificEpithet", "species");
		col_subspecies = column("infraspecificEpithet", "subspecies");
		
		nameColumns.add(col_canonicalname);
		nameColumns.add(col_scientificname);
		nameColumns.add(col_acceptedname);
		nameColumns.add(col_family);
		nameColumns.add(col_genus);
		nameColumns.add(col_species);
		nameColumns.add(col_subspecies);
		nameColumns.remove(-1);	// Remove any blank fields from before.
	}
	
	private void indexNames() {
		
		// TODO: Some of this parsing code can and should move into the Name model.
		
		if(col_canonicalname < 0) {
			// If there is no canonical name, create one.
			
			if(col_genus >= 0 && col_species >= 0) {
				List<String[]> new_data = new ArrayList<String[]>();
				
				for(String[] row: data) {
					String[] new_row = new String[row.length + 1];
					System.arraycopy(row, 0, new_row, 0, row.length);
					
					String genus = row[col_genus];
					String species = row[col_species];
					String subspecies = "";
					
					if(col_subspecies >= 0) {
						subspecies = row[col_subspecies];
					}
					
					if(genus.length() > 0 && species.length() > 0) {
						if(subspecies.length() > 0) {
							new_row[row.length] = genus + " " + species + " " + subspecies;
						} else {
							new_row[row.length] = genus + " " + species;
						}
					} else {
						new_row[row.length] = "";
					}
					
					if(new_row[row.length] != null) {
						new_row[row.length] = new_row[row.length].trim();
					}
					
					new_data.add(new_row);
				}		
				
				columns.add("canonicalName");
				col_canonicalname = columns.size() - 1;
				data = new_data;
				
				if(col_subspecies >= 0) {
					colsUsedToGenerateCanonicalName = column(col_genus) + ", " + column(col_species) + " and " + column(col_subspecies);
				} else {
					colsUsedToGenerateCanonicalName = column(col_genus) + " and " + column(col_species);
				}
		
			}
			else
			if(col_scientificname >= 0) {
				// Parse a canonical name out of a scientific name.
				Pattern p_canonical = Pattern.compile("^\\s*([A-Z][a-z]+\\s+[a-z]+(?:\\s+[a-z]+)?)\\b"); // \\s+[a-z]+(?:\\s+[a-z]+))\\b");
				Pattern p_monomial = Pattern.compile("^\\s*([A-Z](?:[a-z]+|[A-Z]+))\\b");
				
				List<String[]> new_data = new ArrayList<String[]>();
				
				for(String[] row: data) {
					String[] new_row = new String[row.length + 1];
					System.arraycopy(row, 0, new_row, 0, row.length);
					
					Matcher m = p_canonical.matcher(row[col_scientificname]);
					// System.err.println(m.find() + " between '" + row[col_scientificname] + "' and '" + p_canonical + "'");
					if(m.lookingAt()) {
						new_row[row.length] = m.group(1);
					} else {
						m = p_monomial.matcher(row[col_scientificname]);
						if(m.lookingAt()) {
							new_row[row.length] = m.group(1);
						} else {
							new_row[row.length] = "";
						}
					}
					
					new_data.add(new_row);
				}
				
				columns.add("canonicalName");
				col_canonicalname = columns.size() - 1;
				data = new_data;
				
				colsUsedToGenerateCanonicalName = column(col_scientificname);
			}
		}
		
		// Choose a name to index.
		int col_name = -1;
		if(col_canonicalname >= 0) {
			col_name = col_canonicalname;
		} else if(col_scientificname >= 0) {
			col_name = col_scientificname;
		}
		
		names.clear();
		if(col_name >= 0) {
			for(String[] row: data) {
				names.add(row[col_name].toLowerCase());
			}
		}
	}
	
	public List<String> columns() {
		return columns;
	}
	
	public String column(int colIndex) {
		return columns.get(colIndex);
	}
	
	// Note: case-insensitive by default.
	public int column(String... colNames) {
		for(String colName: colNames) {
			Integer i = columnNames_caseInsensitive.get(colName.toLowerCase());
			if(i != null)
				return i.intValue();
		}
		return -1;
	}
	
	public List<String[]> rows() {
		return data;
	}
	
	public String[] row(int row) {
		return data.get(row);
	}

	@Override
	public int getRowCount() {
		return data.size();
	}

	@Override
	public int getColumnCount() {
		return columns.size();
	}

	@Override
	public String getColumnName(int columnIndex) {
		return columns.get(columnIndex);
	}

	@Override
	public Class<?> getColumnClass(int columnIndex) {
		if(nameColumns.contains(columnIndex))
			return Name.class;
		else 
			return String.class;
	}

	@Override
	public boolean isCellEditable(int rowIndex, int columnIndex) {
		return true;
	}

	@Override
	public Object getValueAt(int rowIndex, int columnIndex) {
		if(getColumnClass(columnIndex) == Name.class) {
			return new Name(data.get(rowIndex)[columnIndex]);
		} else {	
		return data.get(rowIndex)[columnIndex];
		}
	}

	@Override
	public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
		data.get(rowIndex)[columnIndex] = aValue.toString();
		for(TableModelListener tmi: tmiList) {
			tmi.tableChanged(new TableModelEvent(this, rowIndex, rowIndex, columnIndex, TableModelEvent.UPDATE));
		}
	}

	private ArrayList<TableModelListener> tmiList = new ArrayList<TableModelListener>();
	
	@Override
	public void addTableModelListener(TableModelListener l) {
		tmiList.add(l);
	}

	@Override
	public void removeTableModelListener(TableModelListener l) {
		tmiList.remove(l);
	}

	private DefaultTableCellRenderer defTableCellRenderer = new DefaultTableCellRenderer();
	
	@Override
	public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
		Component c = defTableCellRenderer.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
        c.setBackground(Color.WHITE);
        
		if(column == col_family || column == col_scientificname || column == col_acceptedname || column == col_canonicalname) {
			Name name = (Name) value;
			String str = name.toString();
			
			if(matcher == null) {
				if(str.length() == 0) {
					c.setBackground(Color.GRAY);
				} else {
					c.setBackground(new Color(137, 207, 230));
				}
			} else {
				if(str.length() == 0) {
					c.setBackground(Color.GRAY);
				} else if(matcher.hasName(str)) {
					c.setBackground(new Color(0, 128, 0));
				} else if(matcher.hasName(name.getGenus())) {
					c.setBackground(new Color(255, 117, 24));
				} else {
					c.setBackground(new Color(226, 6, 44));
				}
			}
		}
		
		return c;
	}

	private DarwinCSV matcher = null;
	public void match(DarwinCSV csv_matcher) {
		matcher = csv_matcher;
		for(TableModelListener tmi: tmiList) {
			tmi.tableChanged(new TableModelEvent(this, 0, getRowCount()));
		}
	}

	public boolean hasName(String str) {
		if(str == null)
			return false;
		return names.contains(str.trim().toLowerCase());
	}

	public void saveToFile(File file, int type) throws IOException {
		CSVWriter writer = null;
		
		if(type == FILE_CSV_DELIMITED) {
			writer = new CSVWriter(new FileWriter(file));
		} else {
			throw new UnsupportedOperationException("File type " + type + " not yet supported!");
		}
		
		writer.writeNext(columns.toArray(new String[columns.size()]));
		writer.writeAll(data);
		writer.flush();
		writer.close();
	}

	public int getCanonicalNameColumn() {
		return col_canonicalname;
	}

	public String generateTextSummaryOfColumn(String colName) {
		StringBuilder builder = new StringBuilder();
		
		if(colName == null) {
			// Report on the name and the match.
		
			builder.append("Currently loaded file: ").append(myFile.getAbsolutePath()).append("\n");
			builder.append("  Number of rows: ").append(data.size()).append("\n");
			builder.append("  Scientific name column: ").append(getColumnInformation(col_scientificname)).append("\n");
			builder.append("  Canonical name column: ").append(getColumnInformation(col_canonicalname)).append("\n");
			
		} else {
			// Report on the column.
			int colIndex = column(colName);
			
			builder.append("Information about column: ").append(getColumnInformation(colIndex)).append("\n");
			
			// This should really be cached!
			int blank_rows = 0;
			int total_non_blank = 0;
			int total_matched = 0;
			int total_genus_matched = 0;
			int total_not_matched = 0;
			HashMap<String, Integer> uniqueValues = new HashMap<String, Integer>();
			HashSet<String> matchedNames = new HashSet<String>();
			HashSet<String> matchedGenusNames = new HashSet<String>();
			boolean matched = false;
			
			for(String[] row: data) {
				String val = row[colIndex];
				if(val == null || val.equals("")) {
					blank_rows++;
				} else {
					total_non_blank++;
					
					if(!uniqueValues.containsKey(val)) {
						uniqueValues.put(val, new Integer(1));
					} else {
						uniqueValues.put(val, new Integer(uniqueValues.get(val).intValue() + 1));
					}
					
					if(matcher != null && (colIndex == col_family || colIndex == col_scientificname || colIndex == col_acceptedname || colIndex == col_canonicalname)) {
						matched = true;
						
						if(matcher.hasName(val)) {
							matchedNames.add(val);
							total_matched++;
						} else if(matcher.hasName(new Name(val).getGenus())) {
							matchedGenusNames.add(val);
							total_genus_matched++;
						} else {
							total_not_matched++;
						}
					}
				}
			}
			
			int possible_values = uniqueValues.size();
			builder.append("  Possible values: ").append(possible_values).append("\n");
			builder.append("    Blank rows: ").append(number_and_percentage(blank_rows, data.size())).append("\n");
			builder.append("    Non-blank rows: ").append(number_and_percentage(total_non_blank, data.size())).append("\n");
			
			if(matched) {
				builder.append("    Names were matched against ").append(matcher.toString()).append(". (percentages are against non-blank rows)\n");
				builder.append("      Matched names: ").append(number_and_percentage(total_matched, total_non_blank)).append("\n");
				builder.append("      Matched genus names: ").append(number_and_percentage(total_genus_matched, total_non_blank)).append("\n");
				builder.append("      Unmatched names: ").append(number_and_percentage(total_not_matched, total_non_blank)).append("\n");
			}
			
			builder.append("\n");
			builder.append("    Values: (percentages refer to total non-blank rows)\n");
		
			ValueComparator<String, Integer> comparator = new ValueComparator<String, Integer>(uniqueValues);
			TreeSet<String> sortByValues = new TreeSet<String>(comparator);
			sortByValues.addAll(uniqueValues.keySet());
			
			for(String val: sortByValues.descendingSet()) {
				if(val == null)
					val = "(null)";
				Integer count = uniqueValues.get(val);
				if(count == null)
					count = new Integer(-1);
				
				String s_matched = "";
				if(matched) {
					if(matchedNames.contains(val))
						s_matched = "\tmatched";
					else if(matchedGenusNames.contains(val))
						s_matched = "\tmatched to genus";
					else
						s_matched = "\tnot matched";
				}
				
				builder.append("\t").append(val).append(s_matched).append("\t").append(number_and_percentage(count.intValue(), total_non_blank)).append("\n");
			}
		}
		
		return builder.toString();
	}
	
	private String number_and_percentage(int number, int total) {
		return number + "\t" + percentage(number, total) + "%";
	}
	
	NumberFormat nf = null;
	private String percentage(double d1, double d2) {
		if(nf == null) {
			nf = NumberFormat.getNumberInstance();
			nf.setMinimumFractionDigits(1);
		}
		
		return nf.format((d1/d2)*100);
	}
	
	private String percentage(double d1) {
		return percentage(d1, 1.0d);
	} 
	
	public String getColumnInformation(int columnIndex) {
		if(columnIndex == -1)
			return "None";
		
		if(columnIndex < 0 || columnIndex > columns.size())
			return "Invalid column identifier";
		
		String ret = columns.get(columnIndex) + " (#" + (columnIndex + 1) + ")";
		
		if(columnIndex == col_canonicalname && colsUsedToGenerateCanonicalName != null)
			ret += " [autogenerated from " + colsUsedToGenerateCanonicalName + "]";
		
		return ret;
	}
}
