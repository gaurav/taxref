
/*
 *
 *  Name
 *  Copyright (C) 2012 Gaurav Vaidya
 *
 *  This file is part of TaxRef.
 *
 *  TaxRef is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  TaxRef is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with TaxRef.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

package com.ggvaidya.TaxRef.Model;

import java.util.*;
import java.util.regex.*;

/**
 * A Name is a scientific name-string.
 * 
 * Advantages:
 *	- Name string comparisons are always case-insensitive.
 *  - 
 * 
 * @author Gaurav Vaidya <gaurav@ggvaidya.com>
 */
public class Name {
	String namestring = "";
	String namestring_lc = "";
	String monomial = null;
	String genus = null;
	String species = null;
	String subspecies = null;
	
	private boolean parsed = false;
	
	private static int cache_hit = 0;
	private static int cache_miss = 0;
	
	private static HashMap<String, Name> cache = new HashMap<String, Name>();
	
	public static Name getName(String name) {
		if(cache.containsKey(name)) {
			// System.err.println("Cache hit (" + (cache_hit++) + "): " + name);
			return cache.get(name);
		}
		// System.err.println("Cache miss (" + (cache_miss++) + "): " + name);
		Name n = new Name(name);
		cache.put(name, n);
		return n;
	}
	
	public Name(String str) {
		namestring = str;
		namestring_lc = namestring.toLowerCase();
		
		// System.err.println("Name '" + namestring + "': genus '" + genus + "', species '" + species + "', subspecies '" + subspecies + "'");
	}
	
	private void parseName() {
		if(parsed)
			return;
		
		Pattern p_canonical = Pattern.compile("^\\s*([A-Z][a-z]+)\\s+([a-z]+)(?:\\s+([a-z]+))?\\b"); // \\s+[a-z]+(?:\\s+[a-z]+))\\b");
		Pattern p_monomial = Pattern.compile("^\\s*([A-Z](?:[a-z]+|[A-Z]+))\\b");
		
		Matcher m = p_canonical.matcher(namestring);
		//System.err.println(m.find() + " between '" + row[col_scientificname] + "' and '" + p_canonical + "'");
		if(m.lookingAt()) {
			genus = m.group(1);
			species = m.group(2);
			subspecies = m.group(3);
		} else {
			m = p_monomial.matcher(namestring);
			if(m.lookingAt()) {
				monomial = m.group(1);
			} else {
				monomial = namestring;
			}
		}
		
		parsed = true;
	}
	
	public String getNamestring() {
		return namestring;
	}
	
	public String getNamestringLC() {
		return namestring_lc;
	}
	
	public String getGenus() {
		if(!parsed) parseName();
		
		return genus;
	}
	
	public String getSpecificEpithet() {
		if(!parsed) parseName();
		
		return species;
	}
	
	public String getMonomial() {
		if(!parsed) parseName();
		
		return monomial;
	}
	
	public String getBinomial() {
		if(!parsed) parseName();
		
		if(genus == null || species == null)
			return "";
		
		return genus + " " + species;
	}
	
	public String getScientificName() {
		if(!parsed) parseName();
		
		if(subspecies != null && genus != null && species != null)
			return genus + " " + species + " " + subspecies;
		else {
			if(genus != null && species != null)
				return genus + " " + species;
			else
				return monomial;
		}
	}
	
	public String toString() {
		return namestring;
	}

	@Override
	public boolean equals(Object o) {
		if(o == null)
			return false;
		
		if(Name.class.isAssignableFrom(o.getClass())) {
			Name n = (Name) o;
			
			if(getNamestringLC().equals(n.getNamestringLC()))
				return true;
			else
				return false;
		} else
			return false;
	}

	@Override
	public int hashCode() {
		/*
		 * This code was generated by NetBeans! So cool.
		 * 
		int hash = 7;
		hash = 79 * hash + (this.namestring != null ? this.namestring.hashCode() : 0);
		return hash;
		*/
		
		return namestring.hashCode();
	}
}
